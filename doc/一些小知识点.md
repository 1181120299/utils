# 1、死锁

**死锁的产生**：有两种情形会产生死锁问题。

**（1）第一种死锁的情形**：A线程首先更新了id=1的书籍（Book）信息，想要更新id=6的作家（Author）信息。B线程首先更新了id=6的作家（Author）信息，想要更新id=1的书籍（Book）信息。但是两个线程的第二步都拿不到想要的资源锁，导致出现互相等待的情况，即产生死锁。

但是假如说A线程首先更新的书籍（Book）信息id=2，此时两个线程是不会出现死锁问题的。数据库引擎做了优化（至少innodb是这样的），排它锁是针对每一行数据的，比如说锁了id=1数据的时候，别的线程一样可以拿到id=2数据的排它锁，进行更新、删除操作。

**解决方案**：针对这种死锁类型的解决，有两种方案。

第一种方案：规范资源的获取顺序。比如说A、B两个线程，都是先更新书籍（Book），然后再更新作家（Author）。这样就能避免死锁，首先拿到书籍（Book）排它锁的线程先执行完成，然后另一线程才开始执行。

第二种方案：资源获取顺序没有办法规范的情况下，可以通过加锁来解决。可以在方法签名上加`synchronized`关键字（此时锁的是当前类的class对象），或者代码中通过`ReentrantLock`、`synchronized`等添加对象锁。这样只有拿到特定对象的对象锁，才能执行代码（更新书籍，更新作家）。

**（2）第二种死锁的情形**：同一个线程内，A方法先插入了一条书籍（Book），假设id=1。然后调用B方法进行了某种处理，B方法对id=1的书籍记录进行了更新操作。如果B方法是在新的事务上（Propagation.REQUIRES_NEW）进行的，那么此时就是出现死锁问题。因为A方法持有了id=1的书籍数据的排它锁，但是A方法所在的事务被挂起了没有提交，B方法又拿不到id=1的书籍数据的排它锁没法update。

**解决方案：**针对这种死锁类型的解决，有两种方案。

第一种方案：insert和update在同一事务中处理。

第二种方案：如果说处于某种原因，insert和update必须要在不同的事务中处理（update失败不能影响insert事务）。那么可以考虑业务解耦，例如通过消息队列，通过消息消费的方式处理update逻辑。也可以通过线程池去update，但是此时update所在的事务，由于在别的线程，将不会由spring进行管理，必须手动提交或者回滚事务。

**补充**：多线程事务问题。

多线程事务：本身就是一个伪命题，违背了事务四个特性（ACID）中的I：隔离性。隔离性是指在并发的环境下，事务之间互不影响。

新开线程的事务，和主线程的事务互相隔离，也不会交由Spring管理。子线程只能手动管理事务。